package graphs;

import java.util.*;

public class ToposortDAGSolver<V> implements ShortestPathSolver<V> {
    private final Map<V, Edge<V>> edgeTo;
    private final Map<V, Double> distTo;
    private final V start;

    public ToposortDAGSolver(Graph<V> graph, V start) {
        this.edgeTo = new HashMap<>();
        this.distTo = new HashMap<>();
        this.start = start;

        edgeTo.put(start, null);
        distTo.put(start, 0.0);
        // TODO: Your code here!
        dfs(graph, start);
        Collections.reverse(order);
        for (V from : order) {
            for (Edge<V> edge : graph.neighbors(from)) {
                V to = edge.to();
                double oldDist = distTo.getOrDefault(to, Double.POSITIVE_INFINITY);
                double newDist = distTo.get(from) + edge.weight();
                if (newDist < oldDist) {
                    distTo.put(to, newDist);
                    edgeTo.put(to, edge);
                }
            }
        }

    }

    // TODO: Your code here!
    Set<V> visited = new HashSet<>();
    List<V> order = new ArrayList<>();
    private void dfs(Graph<V> graph, V start) {
        visited.add(start);
        if (!graph.neighbors(start).isEmpty()){
            for (Edge<V> edge : graph.neighbors(start)) {
                V to = edge.to();
                if (!visited.contains(to)) {
                    dfs(graph, to);
                }
            }
        }
        order.add(start);
    }

    public List<V> solution(V goal) {
        List<V> path = new ArrayList<>();
        V curr = goal;
        path.add(curr);
        while (edgeTo.get(curr) != null) {
            curr = edgeTo.get(curr).from();
            path.add(curr);
        }
        Collections.reverse(path); // the shortest path
        return path;
    }
}
